{
  "hash": "a2f1eea72c6a88ab145cbf61ea390e10",
  "result": {
    "markdown": "---\ntitle: \"อ่านไฟล์ในอาร์ด้วย readr package\"\ndate: \"2022-19-11\"\ncategories: [R]\ndraft: false\ntoc: true \nexecute: \n  eval: true\n  echo: true\n  warning: true\n  message: true\n---\n\n\n![](https://images.unsplash.com/photo-1457369804613-52c61a468e7d?q=80&w=2670&auto=format&fit=crop&ixlib=rb-4.0.3&ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D)\n\n# บทนำ\n\nแพ็คเกจ readr สำหรับผมแล้วถือว่าเป็นแพ็คเกจเริ่นต้นที่จะใช้เพื่ออ่านไฟล์ ซึ่ง ที่จริงแล้ว base ในอาร์ ก็มีฟังชัน เช่น `read.csv()` `read.tab()` อ่านไฟล์ *.csv หรือ* .tab อยู่แล้ว แล้ว มันดีอย่างไร กลุ่มผู้พัฒนา พัฒนาแพคเกจนี้มาเพื่อ ให้อาร์อ่านไฟล์ได้อย่างรวดเร็วและเหมาะสมกับข้อมูลภาคตัดขวาง rectangular data เช่น csv tsv และ fwf ที่ออกแบบมาเพื่อแยกวิเคราะห์ข้อมูลหลายประเภท ถ้ารู้ว่ากำลังทำงานกัับไฟล์ที่มีข้อมูลจำนวนนาน หรือขนาดใหญ่ แพคเกจนี้\n\nแพ็คเกจ readr ได้รับการพัฒนาเมื่อเร็ว ๆ นี้โดย Hadley Wickham เพื่อจัดการกับการอ่านในไฟล์แบนขนาดใหญ่ได้อย่างรวดเร็ว แพ็คเกจนี้มีการแทนที่ฟังก์ชันต่างๆ เช่น `read.table()` และ `read.csv()` ฟังก์ชันใน readr คือ `read_table()` และ `read_csv()` ฟังก์ชันเหล่านี้มักจะเร็วกว่า base R พื้นฐานมากและมีคุณสมบัติที่ดีอื่น ๆ อีก\n\nโดยจะใช้ `read_table()` และ `read_csv()` แทน `read.table()` และ `read.csv()` ได้เลย แต่ ถ้าเมื่อพบอะไรแปลก ๆ ของข้อมูลในๆฟล์ที่ใช้งาน จะอ่านและ แจ้งเตือน ซึ่ง ดีต้องที่ สามารถแก้ไขได้ ก่อนเอาข้อมูลไปวิเคราะห์ต่อไป\n\nข้อดีของ `read_csv()` ที่ดีต่อใจกว่า `read.csv()` คืออ่านได้รวดกว่า แล้วก็ยังสามารถระบุ ชนิด ประเภทอของคอลัมน์ได้อย่างไม่เย้นเย้อ ได้เป็นไปได้ ก็อยากจะให้ใช้ `read_csv()` มากกว่าแบบเดิม\n\n# readr 101\n\n\n::: {.cell title='open readr package'}\n\n```{.r .cell-code}\nlibrary(readr)\n```\n:::\n\n\nก่อนจะใช้ฟังก์ชัน จะต้องเปิดแพคเกจ `readr` หรือ ถ้าใครใช้ แพคเกจ `tidyverse` ก็ไม่ต้องแล้วเพราะมาชุดแล้ว\n\n\n::: {.cell}\n\n```{.r .cell-code}\nblight_yield <- read_csv(file = \"bud-blight-soybean.csv\")\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nRows: 64 Columns: 4\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr (1): treat\ndbl (3): time, block, y\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n```\n:::\n:::\n\n\n::: callout-note\n`readr` แสดงประเภทคอลัมน์ที่คาดเดาว่าน่าจะเป็นอะไร ซึ่ง ค่าเริ่มต้นขณะที่เรายังไม่ระบุว่าคอลัมน์แต่ละอันเป็นประเภทอะไร ซึ่ง มีประโยชน์ ช่วยตรวจสอบว่าคอลัมน์ถูกอ่านตามคิดไว้หรือไม่ ถ้าไม่ต้องระบุ คราวๆ เราอาจจะดูก่อนว่า มันกดหนดไว้เป็นอย่างไรบ้าง โดยใช้ฟังก์ชัน `spec()` เพื่อดึงข้อมูลประเภท คอลัมน์ที่คาดการณ์ไว้ (เดา)\n:::\n\n## ระบุ ชนิดของ column\n\n\n::: {.cell}\n\n```{.r .cell-code}\nspec(blight_yield)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\ncols(\n  treat = col_character(),\n  time = col_double(),\n  block = col_double(),\n  y = col_double()\n)\n```\n:::\n:::\n\n\nลองมาดูกันก่อนว่า จะมี argument อะไรบ้างที่ใช้ระบุคอลัม - The available specifications are: (with string abbreviations in brackets)\n\n-   `col_logical()` สำหรับคอลัมตัวแปรที่เก็บค่าเป็น T, F, TRUE or FALSE.\n\n-   `col_integer()` สำหรับคอลัมตัวแปรที่เก็บค่าเป็น integers.\n\n-   `col_double()` สำหรับคอลัมตัวแปรที่เก็บค่าเป็น doubles.\n\n-   `col_character()` สำหรับคอลัมตัวแปรที่เก็บค่าเป็น ตัวอักษร หรือ คำ\n\n-   `col_factor(levels, ordered)` สำหรับคอลัมตัวแปรที่เก็บค่าเป็น factor\n\n-   `col_date(format = \"\")` สำหรับคอลัมตัวแปรที่เก็บค่าเป็น date format.\n\n-   `col_time(format = \"\")` สำหรับคอลัมตัวแปรที่เก็บค่าเป็น time format.\n\n-   `col_datetime(format = \"\")` \\[T\\]: ISO8601 date times\n\n-   `col_number()` สำหรับคอลัมตัวแปรที่เก็บค่าเป็นตัวเลข grouping_mark\n\n-   `col_skip()` สำหรับข้าม(ไม่อ่าน)คอลัมตัวแปรนี้\n\n-   `col_guess()` กดหนดให้เดาประเภทของตัวแปร\n\nก็กอปปี้มา\n\n```         \ncols(\ntreat = col_character(), \ntime = col_double(), \nblock = col_double(), \ny = col_double() \n)\n```\n\nมาใส่ต่อถ้าเลย แล้วก็แก้ ตามความต้องการ จึงได้มาเป็น\n\n\n::: {.cell}\n\n```{.r .cell-code}\nblight_yield <- read_csv(\n  file = \"bud-blight-soybean.csv\",\n  col_types = cols(\n              treat = col_factor(levels = c(\"PD1\", \"PD2\", \"PD3\", \"PD4\")),\n              time  = col_factor(levels = c(\"30\", \"40\", \"50\", \"60\")),\n              block = col_factor(levels = c(\"1\", \"2\", \"3\", \"4\")),\n              y     = col_double()\n              )\n)\n```\n:::\n\n\nหรือ จะสั้น ๆ แบบนี้ก็ได้ แต่ก็ไม่ค่อยดีกับประเภทที่เป็น factor ซึ่ง จะจะเรียงลำดับค่า factor ไม่ตรงกับที่เราต้องการได้ ก็ได้ แล้ว จะต้องมาแก้ไข\n\n\n::: {.cell}\n\n```{.r .cell-code}\nblight_yield <- read_csv(\n  file = \"bud-blight-soybean.csv\",\n  col_types = \"fffd\"\n  )\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nblight_yield |> dplyr::glimpse()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nRows: 64\nColumns: 4\n$ treat <fct> PD1, PD1, PD1, PD1, PD1, PD1, PD1, PD1, PD1, PD1, PD1, PD1, PD1,…\n$ time  <fct> 30, 30, 30, 30, 40, 40, 40, 40, 50, 50, 50, 50, 60, 60, 60, 60, …\n$ block <fct> 1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4, 1, 2…\n$ y     <dbl> 0.10, 0.30, 0.10, 0.10, 0.30, 0.38, 0.36, 0.37, 0.57, 0.52, 0.50…\n```\n:::\n:::\n\n\n::: callout-note\nไฟล์ที่อ่าน โดย `read_*` จาก แพคเกจ `readr` จะเป็นข้อมูลประเภท tibble\n:::\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}